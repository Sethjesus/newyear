<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <!-- æ‰‹æ©Ÿå‹å–„ Â· 3Dæ–‡å­—æ”¾å¤§ï¼‹JACKYéŸ³æ•ˆï¼‹é è¨­éŸ³æ¨‚è‡ªå‹•æ’­æ”¾ Â· å¥‰å¤©å®® Â· é›™é¦¬æ˜é¡¯æ˜¥è¯ Â· è²¡ç¥èµ°å…¥ï¼‹è¨±å¤šå…ƒå¯¶å¾å¥‰å¤©å®®å™´ç™¼ -->
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.5, user-scalable=yes, viewport-fit=cover">
    <title> é¦¬å¹´å…ƒå¯¶æ»¿å¤©é£› Â·</title>
    <style>
        /* ********** è²¡ç¥å ±å–œ Â· ç´…é‡‘å¹´å‘³ Â· é‹å‹•è‡ªç„¶ ********** */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background: #9f3a2a;
            font-family: "Noto Serif TC", "æ¨™æ¥·é«”", "PingFang TC", sans-serif;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 20px;
            position: relative;
            background-image: radial-gradient(circle at 10% 30%, #b84a3a 0%, #8f3a2a 100%);
        }

        /* è‡ªç„¶é‹å‹•iconè£é£¾ */
        body::before {
            content: "ğŸ®è²¡ç¥ğŸ® ğŸ´ğŸƒ ğŸš´ ğŸ§— ğŸŒ¿ â˜ï¸ â›°ï¸ ğŸª™ğŸª™ğŸª™";
            position: fixed;
            top: 10px;
            left: 0px;
            font-size: 32px;
            color: rgba(255, 255, 180, 0.35);
            white-space: nowrap;
            transform: rotate(-3deg);
            pointer-events: none;
            z-index: 3;
            letter-spacing: 12px;
            width: 100%;
            text-shadow: 2px 2px 0 #5a2a1a;
        }

        body::after {
            content: "ğŸ§§ğŸ´ğŸ§§ğŸ´ğŸ§§ å¥‰å¤©å®® å…ƒå¯¶æ»¿å¤© ğŸ§§ğŸ´ğŸ§§ğŸ´ğŸ§§";
            position: fixed;
            bottom: 10px;
            right: 0px;
            font-size: 30px;
            color: rgba(255, 220, 100, 0.4);
            white-space: nowrap;
            transform: rotate(4deg);
            pointer-events: none;
            z-index: 3;
        }

        /* éŸ³æ¨‚åˆ— æœ€ä¸Šæ–¹ */
        .music-row-top {
            width: 100%;
            max-width: 580px;
            background: #6a2e1e;
            border: 4px solid #ffd97a;
            border-radius: 70px;
            padding: 12px 22px;
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 15px;
            box-shadow: 0 8px 0 #5a2a1a;
            z-index: 20;
        }
        .music-btn {
            background: #ffc56e;
            border: none;
            color: #6a2a1a;
            font-size: min(32px, 6.5vw);
            font-weight: bold;
            padding: 8px 26px;
            border-radius: 60px;
            border-bottom: 6px solid #b85a2a;
            cursor: pointer;
            transition: transform 0.06s;
        }
        .music-btn:active {
            transform: translateY(4px);
            border-bottom-width: 2px;
        }

        /* ä¸»ç´…åŒ…å¡ */
        .red-card {
            background: #c43c1e;
            max-width: 580px;
            width: 100%;
            border-radius: 50px 50px 30px 30px;
            border: 10px solid #ffd97a;
            box-shadow: 0 12px 0 #7a3a2a;
            padding: 32px 24px;
            display: flex;
            flex-direction: column;
            align-items: center;
            position: relative;
            z-index: 20;
            border-bottom: 8px solid #b85a2a;
        }

        .red-card::before {
            content: "ğŸ´ Jacky æ‹œå¹´  å…ƒå¯¶æ»¿å¤©é£› ğŸ´";
            position: absolute;
            top: -18px;
            left: 8%;
            width: 84%;
            background: #ffd966;
            color: #a03a2a;
            font-size: min(26px, 5.5vw);
            font-weight: 900;
            text-align: center;
            padding: 10px 0;
            border-radius: 50px;
            border: 4px solid #ffb84d;
            box-shadow: 0 6px 0 #9f4a2a;
            letter-spacing: 4px;
        }

        .sheng-big {
            font-size: min(90px, 18vw);
            font-weight: 900;
            color: #fffacd;
            text-shadow: 6px 6px 0 #7a3a2a;
            line-height: 1;
            margin-top: 20px;
            margin-bottom: 8px;
        }

        /* ç­Šæ¯å€ */
        .bwa-panel {
            background: #6a2e1e;
            border: 6px solid #ffc56e;
            border-radius: 70px 70px 30px 30px;
            padding: 26px 22px;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 16px;
            max-width: 580px;
            width: 100%;
            margin-top: 20px;
            box-shadow: 0 12px 0 #5a2e1e;
            border-top: 8px solid #ffcc66;
            z-index: 20;
        }

        .moon {
            font-size: min(120px, 22vw);
            background: #3a1e1e;
            padding: 8px 45px;
            border-radius: 180px;
            border: 6px solid #ffc56e;
            filter: drop-shadow(0 8px 0 #7a3a2a);
            line-height: 1;
            cursor: pointer;
            color: #fffacd;
        }

        .shake-btn {
            font-size: min(34px, 7vw);
            font-weight: 900;
            background: #8a3a2a;
            color: #fffacd;
            padding: 12px 28px;
            border-radius: 70px;
            border: 4px solid #ffc56e;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 10px;
            width: 100%;
            cursor: pointer;
            border-bottom: 8px solid #5a2a1e;
            transition: transform 0.08s, border-bottom 0.08s;
        }
        .shake-btn:active {
            transform: translateY(4px);
            border-bottom-width: 4px;
        }

        .result-line {
            font-size: min(36px, 7.5vw);
            font-weight: 900;
            color: #ffecaa;
            background: #5a2a1e;
            padding: 14px 24px;
            border-radius: 60px;
            border: 4px solid #ffc56e;
            text-align: center;
            width: 100%;
            letter-spacing: 4px;
        }

        /* 3Dç«‹é«”ç¥ç¦æ–‡å­—å€ */
        .bless-message-area {
            width: 100%;
            max-width: 580px;
            min-height: 150px;
            background: #8a3a2a;
            border: 4px solid #ffd97a;
            border-radius: 50px;
            margin-top: 25px;
            padding: 20px 20px;
            display: flex;
            align-items: center;
            justify-content: center;
            color: #fffad6;
            font-size: min(32px, 6.8vw);
            font-weight: 900;
            text-align: center;
            word-break: break-word;
            letter-spacing: 4px;
            line-height: 1.5;
            box-shadow: inset 0 0 0 2px #b85a2a, 0 8px 0 #5a2a1e;
            transform-style: preserve-3d;
            background-image: linear-gradient(145deg, #8a3a2a, #a34a2a);
            z-index: 20;
        }

        .bless-message-area.sheng-text-3d {
            animation: text3DBoom 1s cubic-bezier(0.22, 1.52, 0.68, 1) forwards;
        }

        @keyframes text3DBoom {
            0% { color: #fffad6; background: #8a3a2a; border: 4px solid #ffd97a; box-shadow: inset 0 0 0 2px #b85a2a, 0 8px 0 #5a2a1e; text-shadow: 0 0 0 #000; transform: scale(1) translateZ(0) rotateX(0deg) rotateY(0deg); }
            15% { color: #ffffe0; background: #b84a2a; border: 6px solid #ffe88c; box-shadow: inset 0 0 0 3px #d67a3a, 0 0 30px #ffcc33, 0 8px 0 #7a3a2a; text-shadow: 4px 4px 0 #4a1e1e, 8px 8px 0 #3a1a1a, 12px 12px 8px #1a0a0a; transform: scale(1.45) translateZ(25px) rotateX(8deg) rotateY(8deg); }
            40% { color: #ffffff; background: #d65a2a; border: 8px solid #ffec8c; box-shadow: inset 0 0 0 4px #e68a4a, 0 0 45px #ffbb44, 0 8px 0 #8a3a2a; text-shadow: 5px 5px 0 #5a2a1e, 10px 10px 0 #4a1e1e, 15px 15px 10px #2a1212; transform: scale(1.6) translateZ(40px) rotateX(12deg) rotateY(12deg); }
            70% { color: #fffef0; background: #b54a2a; border: 6px solid #ffe282; box-shadow: inset 0 0 0 3px #d67a3a, 0 0 35px #ffbb44, 0 8px 0 #6a2e1e; text-shadow: 3px 3px 0 #4a1e1e, 7px 7px 0 #3a1a1a, 11px 11px 8px #1a0e0e; transform: scale(1.25) translateZ(15px) rotateX(5deg) rotateY(5deg); }
            100% { color: #fffad6; background: #8a3a2a; border: 4px solid #ffd97a; box-shadow: inset 0 0 0 2px #b85a2a, 0 8px 0 #5a2a1e; text-shadow: 0 0 0 #000; transform: scale(1) translateZ(0) rotateX(0deg) rotateY(0deg); }
        }

        /* æ˜¥è¯å€ ç›´å¼ */
        .couplet-area {
            width: 100%;
            max-width: 580px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-top: 20px;
            padding: 0 5px;
            z-index: 20;
        }

        .couplet-left, .couplet-right {
            background: #c43a1e;
            border: 6px solid #ffd97a;
            border-radius: 30px 30px 15px 15px;
            padding: 16px 12px;
            color: #ffecaa;
            font-size: min(26px, 5.5vw);
            font-weight: 900;
            text-align: center;
            writing-mode: vertical-rl;
            text-orientation: upright;
            line-height: 1.8;
            letter-spacing: 0px;
            box-shadow: 0 10px 0 #6a2a1a, inset 0 0 0 2px #ffb84d;
            background-image: linear-gradient(145deg, #b53a1e, #d64a2a);
            min-width: 70px;
        }

        .couplet-left span, .couplet-right span {
            display: block;
            margin: 8px 0;
            text-shadow: 3px 3px 0 #3a1a1a;
        }

        .couplet-center {
            font-size: min(48px, 10vw);
            color: #ffecaa;
            text-shadow: 4px 4px 0 #6a2a1a;
            background: #b53a2a;
            padding: 10px 25px;
            border-radius: 60px;
            border: 6px solid #ffd97a;
            box-shadow: 0 10px 0 #5a2a1a;
            font-weight: 900;
            margin: 0 5px;
            white-space: nowrap;
        }

        /* 3D å¥‰å¤©å®® Canvas å®¹å™¨â€”â€”åŠ å¤§ï¼Œå‹•ç•«è²¡ç¥èµ°å…¥ï¼‹å…ƒå¯¶å™´æ³‰ */
        .temple-box {
            width: 100%;
            max-width: 580px;
            height: 300px;
            border-radius: 40px;
            overflow: hidden;
            border: 6px solid #ffd97a;
            margin-top: 20px;
            background: #4a2e1e;
            position: relative;
            box-shadow: 0 12px 0 #5a2a1a;
            z-index: 25;
        }
        .temple-title {
            position: absolute;
            bottom: 10px;
            right: 20px;
            background: rgba(160, 50, 30, 0.9);
            color: #ffecaa;
            padding: 6px 18px;
            border-radius: 40px;
            font-size: min(20px, 4.5vw);
            font-weight: 900;
            letter-spacing: 6px;
            border: 2px solid #ffcc66;
            z-index: 30;
            pointer-events: none;
            backdrop-filter: blur(2px);
            box-shadow: 0 4px 0 #5a2a1a;
        }
        #templeCanvas {
            width: 100%;
            height: 100%;
            display: block;
        }

        /* é‹å‹•è‡ªç„¶å…ƒç´ åˆ— */
        .sports-nature-row {
            width: 100%;
            max-width: 580px;
            display: flex;
            flex-wrap: wrap;
            align-items: center;
            justify-content: space-around;
            background: rgba(160, 50, 30, 0.8);
            border: 4px solid #ffd97a;
            border-radius: 60px;
            margin-top: 18px;
            padding: 12px 16px;
            backdrop-filter: blur(2px);
            color: #fffad6;
            font-size: min(26px, 5.5vw);
            font-weight: 700;
            box-shadow: 0 8px 0 #5a2a1e;
            border-bottom: 6px solid #8a3a2a;
            z-index: 20;
        }

        .sports-icon, .nature-icon {
            display: flex;
            align-items: center;
            gap: 6px;
            background: #9f3a2a;
            padding: 6px 18px;
            border-radius: 50px;
            border: 2px solid #ffd97a;
            box-shadow: inset 0 0 0 1px #ffb84d;
        }

        .footer-note {
            font-size: min(22px, 5vw);
            color: #ffecaa;
            margin-top: 25px;
            letter-spacing: 8px;
            text-shadow: 2px 2px 0 #5a2a1a;
            z-index: 20;
        }
    </style>
</head>
<body>

    <!-- éŸ³æ¨‚åˆ— Â· æœ€ä¸Šæ–¹ Â· é è¨­è‡ªå‹•æ’­æ”¾ -->
    <div class="music-row-top">
        <span style="font-size: min(32px, 6.5vw); color: #ffecaa;">ğŸµ Jacky è²¡ç¥åˆ° Â· å…ƒå¯¶å™´ç™¼</span>
        <button id="musicToggle" class="music-btn">ğŸ”Š</button>
    </div>

    <!-- ä¸»ç´…åŒ… Â· è–ç­Šé›™é¦¬ -->
    <div class="red-card">
        <div class="sheng-big">è–ç­Š</div>
        <div style="font-size: min(44px, 10vw); color: #ffecaa; text-shadow: 4px 4px 0 #6a2a1a;">
            ğŸ´ğŸ§§ğŸª™ğŸ´ğŸƒ
        </div>
    </div>

    <!-- ç­Šæ¯äº’å‹•å€ -->
    <div class="bwa-panel">
        <div id="moonDisplay" class="moon">ğŸ¥¢ğŸ¥¢</div>
        <div id="resultMessage" class="result-line">ğŸ¥¢ Jacky ç¥è–ç­Š ğŸ´</div>
        <div id="shakeArea" class="shake-btn">
            <span>ğŸ“³</span>
            <span>ğŸ¥¢</span>
            <span>æ– / é» è–ç­Š</span>
            <span>ğŸ´</span>
        </div>
    </div>

    <!-- ç¥ç¦è¨Šæ¯å€ Â· 3Dæ–‡å­—æ”¾å¤§ï¼‹JACKYéŸ³æ•ˆ -->
    <div id="blessDisplay" class="bless-message-area">
        ğŸ´ æ–æ‰‹æ©Ÿ Â· å¾—è–ç­Š Â· å…ƒå¯¶å¾å¥‰å¤©å®®å™´å‡ºä¾†å•¦ï¼
    </div>

    <!-- æ˜¥è¯å€ Â· é›™é¦¬æ˜é¡¯æ˜¥è¯ -->
    <div class="couplet-area">
       
        <div class="couplet-center">
            ğŸ§§å…ƒå¯¶æ»¿å¤©ğŸ§§
        </div>
       
    </div>

    <!-- â˜…â˜…â˜… 3D å¥‰å¤©å®® Â· å»Ÿå¤–é›™é¦¬ ï¼‹ è²¡ç¥èµ°å…¥ ï¼‹ å¤§é‡å…ƒå¯¶å¾å»Ÿå™´å‡º â˜…â˜…â˜… -->
    <div class="temple-box">
        <canvas id="templeCanvas"></canvas>
        <div class="temple-title">ğŸ¯ å¥‰å¤©å®® Â· å…ƒå¯¶å™´æ³‰</div>
    </div>

    <!-- é‹å‹•è‡ªç„¶å…ƒç´ å€ -->
    <div class="sports-nature-row">
        <div class="sports-icon"><span>ğŸƒâ€â™‚ï¸</span> è·‘æ­¥</div>
        <div class="sports-icon"><span>ğŸš´â€â™€ï¸</span> å–®è»Š</div>
        <div class="sports-icon"><span>ğŸ§—â€â™‚ï¸</span> ç™»å±±</div>
        <div class="nature-icon"><span>ğŸŒ²</span> æ£®æ—</div>
        <div class="nature-icon"><span>â˜ï¸</span> æ¸…é¢¨</div>
        <div class="nature-icon"><span>â›°ï¸</span> é«˜å±±</div>
    </div>

    <div class="footer-note">
        ğŸ¥¢ è–ç­Š Â·  å…ƒå¯¶æ»¿å¤©é£› ğŸ´
    </div>

    <!-- èƒŒæ™¯éŸ³æ¨‚ - é è¨­è‡ªå‹•æ’­æ”¾ -->
    <audio id="bgMusic" loop preload="auto" autoplay>
        <source src="https://raw.githubusercontent.com/Sethjesus/newyear/main/horse.mp3" type="audio/mpeg">
        <source src="https://www.soundjay.com/misc/sounds/bell-ringing-05.mp3" type="audio/mpeg">
    </audio>

    <!-- Three.js å¥‰å¤©å®®æ¨¡çµ„ + è²¡ç¥(å¸¶å…ƒå¯¶)èµ°å…¥å‹•ç•« + é›™é¦¬ + å…ƒå¯¶å™´æ³‰ -->
    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.128.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.128.0/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        // ---------- 3D å¥‰å¤©å®® Â· é›™é¦¬ Â· è²¡ç¥èµ°å…¥ Â· å¤§é‡å…ƒå¯¶å¾å»Ÿå™´ç™¼ ----------
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

        const canvas = document.getElementById('templeCanvas');
        const w = canvas.clientWidth;
        const h = canvas.clientHeight;

        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x8f3a2a); // ç´…æ£•åŸºåº•

        const camera = new THREE.PerspectiveCamera(45, w / h, 0.1, 1000);
        camera.position.set(6.5, 4.2, 14);
        camera.lookAt(0, 1.8, 0);

        const renderer = new THREE.WebGLRenderer({ canvas, antialias: true });
        renderer.setSize(w, h);
        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;

        // ç‡ˆå…‰
        const ambient = new THREE.AmbientLight(0xffccaa);
        scene.add(ambient);
        
        const mainLight = new THREE.DirectionalLight(0xffeedd, 1.7);
        mainLight.position.set(6, 12, 12);
        mainLight.castShadow = true;
        mainLight.receiveShadow = true;
        mainLight.shadow.mapSize.width = 1024;
        mainLight.shadow.mapSize.height = 1024;
        scene.add(mainLight);

        const fillLight = new THREE.DirectionalLight(0xffddbb, 0.8);
        fillLight.position.set(-5, 5, 8);
        scene.add(fillLight);

        // ç´…åœŸåœ°é¢
        const ground = new THREE.Mesh(
            new THREE.CircleGeometry(25, 32),
            new THREE.MeshStandardMaterial({ color: 0x9f4a3a, roughness: 0.8, emissive: 0x3a1a1a, emissiveIntensity: 0.1 })
        );
        ground.rotation.x = -Math.PI / 2;
        ground.position.y = -0.05;
        ground.receiveShadow = true;
        scene.add(ground);

        // è‡ªç„¶å…ƒç´ ï¼šå°æ¨¹ (é‹å‹•è‡ªç„¶)
        function addTree(x, z, size) {
            const trunkMat = new THREE.MeshStandardMaterial({ color: 0x6b4e3a, roughness: 0.9 });
            const leafMat = new THREE.MeshStandardMaterial({ color: 0x3a7a3a, roughness: 0.7, emissive: 0x1a3a1a, emissiveIntensity: 0.1 });
            
            const trunk = new THREE.Mesh(new THREE.CylinderGeometry(0.15 * size, 0.2 * size, 1.2 * size), trunkMat);
            trunk.position.set(x, 0.6 * size, z);
            trunk.castShadow = true;
            trunk.receiveShadow = true;
            scene.add(trunk);
            
            const leaves1 = new THREE.Mesh(new THREE.ConeGeometry(0.7 * size, 0.7 * size, 8), leafMat);
            leaves1.position.set(x, 1.3 * size, z);
            leaves1.castShadow = true;
            leaves1.receiveShadow = true;
            scene.add(leaves1);
            
            const leaves2 = new THREE.Mesh(new THREE.ConeGeometry(0.5 * size, 0.6 * size, 8), leafMat);
            leaves2.position.set(x, 1.8 * size, z);
            leaves2.castShadow = true;
            leaves2.receiveShadow = true;
            scene.add(leaves2);
        }

        addTree(-4.5, -4.5, 1.0);
        addTree(5.0, -4.0, 1.1);
        addTree(-4.8, 4.2, 0.9);
        addTree(4.8, 4.5, 1.0);
        addTree(-3.0, -5.5, 0.8);
        addTree(3.5, 5.5, 0.9);

        // çŸ³é ­
        const stoneMat = new THREE.MeshStandardMaterial({ color: 0x9a7a6a, roughness: 0.9 });
        for (let i = 0; i < 12; i++) {
            const stone = new THREE.Mesh(new THREE.DodecahedronGeometry(0.1 + Math.random()*0.18), stoneMat);
            stone.position.set(3 + Math.random()*5, 0.05, 2 + Math.random()*6);
            stone.rotation.set(Math.random(), Math.random(), Math.random());
            stone.castShadow = true;
            stone.receiveShadow = true;
            scene.add(stone);
        }
        for (let i = 0; i < 12; i++) {
            const stone = new THREE.Mesh(new THREE.DodecahedronGeometry(0.1 + Math.random()*0.18), stoneMat);
            stone.position.set(-3 - Math.random()*5, 0.05, -2 - Math.random()*6);
            stone.rotation.set(Math.random(), Math.random(), Math.random());
            stone.castShadow = true;
            stone.receiveShadow = true;
            scene.add(stone);
        }

        // ========== å¥‰å¤©å®®ä¸»é«” ==========
        const base1 = new THREE.Mesh(
            new THREE.BoxGeometry(5.8, 0.4, 5.4),
            new THREE.MeshStandardMaterial({ color: 0xba8a6a, roughness: 0.7 })
        );
        base1.position.set(0, 0.2, 0);
        base1.castShadow = true;
        base1.receiveShadow = true;
        scene.add(base1);

        const base2 = new THREE.Mesh(
            new THREE.BoxGeometry(5.4, 0.35, 5.0),
            new THREE.MeshStandardMaterial({ color: 0xca9a7a, roughness: 0.7 })
        );
        base2.position.set(0, 0.55, 0);
        base2.castShadow = true;
        base2.receiveShadow = true;
        scene.add(base2);

        const columnBase = new THREE.Mesh(
            new THREE.BoxGeometry(5.0, 0.35, 4.6),
            new THREE.MeshStandardMaterial({ color: 0xdaaa8a, roughness: 0.6 })
        );
        columnBase.position.set(0, 0.95, 0);
        columnBase.castShadow = true;
        columnBase.receiveShadow = true;
        scene.add(columnBase);

        // æŸ±å­
        const columnMat = new THREE.MeshStandardMaterial({ color: 0xc88a4a, roughness: 0.5, emissive: 0x3a2a1a, emissiveIntensity: 0.1 });
        const colPos = [
            [-2.0, 1.5, 1.8], [2.0, 1.5, 1.8],
            [-2.0, 1.5, -1.8], [2.0, 1.5, -1.8]
        ];
        colPos.forEach(pos => {
            const column = new THREE.Mesh(new THREE.CylinderGeometry(0.24, 0.26, 1.7, 8), columnMat);
            column.position.set(pos[0], pos[1], pos[2]);
            column.castShadow = true;
            column.receiveShadow = true;
            scene.add(column);
        });

        // ç‰†èº«
        const wall = new THREE.Mesh(
            new THREE.BoxGeometry(4.8, 1.5, 4.4),
            new THREE.MeshStandardMaterial({ color: 0xb86a4a, roughness: 0.7 })
        );
        wall.position.set(0, 1.55, 0);
        wall.castShadow = true;
        wall.receiveShadow = true;
        scene.add(wall);

        // å»Ÿé–€
        const doorMat = new THREE.MeshStandardMaterial({ color: 0x9a5a3a, roughness: 0.8, emissive: 0x2a1a1a, emissiveIntensity: 0.1 });
        const door = new THREE.Mesh(new THREE.BoxGeometry(1.5, 1.3, 0.25), doorMat);
        door.position.set(0, 1.25, 2.21);
        door.castShadow = true;
        door.receiveShadow = true;
        scene.add(door);

        // å±‹é ‚
        const roofMat1 = new THREE.MeshStandardMaterial({ color: 0xcc8844, roughness: 0.5, emissive: 0x442211, emissiveIntensity: 0.1 });
        const roof1 = new THREE.Mesh(new THREE.ConeGeometry(4.4, 1.0, 4), roofMat1);
        roof1.position.set(0, 2.4, 0);
        roof1.rotation.y = Math.PI / 4;
        roof1.castShadow = true;
        roof1.receiveShadow = true;
        scene.add(roof1);

        const roofMat2 = new THREE.MeshStandardMaterial({ color: 0xbb7733, roughness: 0.5 });
        const roof2 = new THREE.Mesh(new THREE.ConeGeometry(3.8, 0.9, 4), roofMat2);
        roof2.position.set(0, 3.1, 0);
        roof2.rotation.y = Math.PI / 4;
        roof2.castShadow = true;
        roof2.receiveShadow = true;
        scene.add(roof2);

        const roofMat3 = new THREE.MeshStandardMaterial({ color: 0xaa6622, roughness: 0.5 });
        const roof3 = new THREE.Mesh(new THREE.ConeGeometry(3.2, 0.8, 4), roofMat3);
        roof3.position.set(0, 3.8, 0);
        roof3.rotation.y = Math.PI / 4;
        roof3.castShadow = true;
        roof3.receiveShadow = true;
        scene.add(roof3);

        // å¯¶é ‚
        const topMat = new THREE.MeshStandardMaterial({ color: 0xeecc66, emissive: 0x553311, emissiveIntensity: 0.2 });
        const topOrb = new THREE.Mesh(new THREE.SphereGeometry(0.22), topMat);
        topOrb.position.set(0, 4.3, 0);
        topOrb.castShadow = true;
        scene.add(topOrb);

        // ç‡ˆç± 
        const lanternMat = new THREE.MeshStandardMaterial({ color: 0xe84c3c, emissive: 0x441111, emissiveIntensity: 0.2 });
        const lanternPos = [
            [-2.0, 2.3, 1.9], [2.0, 2.3, 1.9],
            [-2.0, 2.3, -1.9], [2.0, 2.3, -1.9]
        ];
        lanternPos.forEach(pos => {
            const lantern = new THREE.Mesh(new THREE.SphereGeometry(0.24), lanternMat);
            lantern.position.set(pos[0], pos[1], pos[2]);
            lantern.castShadow = true;
            lantern.receiveShadow = true;
            scene.add(lantern);
        });

        // é¦™çˆ
        const burnerMat = new THREE.MeshStandardMaterial({ color: 0x8a5a3a, roughness: 0.8 });
        const burner = new THREE.Mesh(new THREE.CylinderGeometry(0.85, 0.95, 0.35, 16), burnerMat);
        burner.position.set(0, 0.35, 1.6);
        burner.castShadow = true;
        burner.receiveShadow = true;
        scene.add(burner);

        // ========== å»Ÿå¤–å…©åŒ¹é¦¬ Â· è¶…ç´šæ˜é¡¯ ==========
        function createHorse(x, z, scaleFactor, colorHex) {
            const horseGroup = new THREE.Group();
            const bodyGeo = new THREE.BoxGeometry(1.0 * scaleFactor, 0.7 * scaleFactor, 1.6 * scaleFactor);
            const bodyMat = new THREE.MeshStandardMaterial({ color: colorHex, roughness: 0.6, emissive: 0x3a1e1a, emissiveIntensity: 0.15 });
            const body = new THREE.Mesh(bodyGeo, bodyMat);
            body.position.y = 0.45 * scaleFactor;
            body.castShadow = true; body.receiveShadow = true;
            horseGroup.add(body);
            
            const headGeo = new THREE.SphereGeometry(0.32 * scaleFactor);
            const headMat = new THREE.MeshStandardMaterial({ color: colorHex, roughness: 0.6 });
            const head = new THREE.Mesh(headGeo, headMat);
            head.position.set(0.55 * scaleFactor, 0.75 * scaleFactor, 0.65 * scaleFactor);
            head.castShadow = true; head.receiveShadow = true;
            horseGroup.add(head);
            
            const neckGeo = new THREE.CylinderGeometry(0.24 * scaleFactor, 0.26 * scaleFactor, 0.5 * scaleFactor);
            const neck = new THREE.Mesh(neckGeo, bodyMat);
            neck.position.set(0.4 * scaleFactor, 0.7 * scaleFactor, 0.6 * scaleFactor);
            neck.rotation.z = -0.3; neck.rotation.x = 0.2;
            neck.castShadow = true; neck.receiveShadow = true;
            horseGroup.add(neck);
            
            const legGeo = new THREE.CylinderGeometry(0.15 * scaleFactor, 0.16 * scaleFactor, 0.55 * scaleFactor);
            const legMat = new THREE.MeshStandardMaterial({ color: colorHex, roughness: 0.7 });
            const leg1 = new THREE.Mesh(legGeo, legMat); leg1.position.set(-0.3 * scaleFactor, 0.2 * scaleFactor, 0.5 * scaleFactor); leg1.castShadow = true; leg1.receiveShadow = true; horseGroup.add(leg1);
            const leg2 = new THREE.Mesh(legGeo, legMat); leg2.position.set(0.25 * scaleFactor, 0.2 * scaleFactor, 0.5 * scaleFactor); leg2.castShadow = true; leg2.receiveShadow = true; horseGroup.add(leg2);
            const leg3 = new THREE.Mesh(legGeo, legMat); leg3.position.set(-0.3 * scaleFactor, 0.2 * scaleFactor, -0.5 * scaleFactor); leg3.castShadow = true; leg3.receiveShadow = true; horseGroup.add(leg3);
            const leg4 = new THREE.Mesh(legGeo, legMat); leg4.position.set(0.25 * scaleFactor, 0.2 * scaleFactor, -0.5 * scaleFactor); leg4.castShadow = true; leg4.receiveShadow = true; horseGroup.add(leg4);
            
            const tailGeo = new THREE.ConeGeometry(0.16 * scaleFactor, 0.45 * scaleFactor, 6);
            const tail = new THREE.Mesh(tailGeo, legMat);
            tail.position.set(-0.5 * scaleFactor, 0.45 * scaleFactor, -0.8 * scaleFactor);
            tail.rotation.x = 0.6; tail.rotation.z = 0.2;
            tail.castShadow = true; tail.receiveShadow = true;
            horseGroup.add(tail);
            
            const earGeo = new THREE.ConeGeometry(0.1 * scaleFactor, 0.16 * scaleFactor, 6);
            const earMat = new THREE.MeshStandardMaterial({ color: colorHex });
            const ear1 = new THREE.Mesh(earGeo, earMat); ear1.position.set(0.6 * scaleFactor, 0.95 * scaleFactor, 0.7 * scaleFactor); ear1.rotation.x = -0.2; ear1.rotation.z = -0.3; ear1.castShadow = true; horseGroup.add(ear1);
            const ear2 = new THREE.Mesh(earGeo, earMat); ear2.position.set(0.75 * scaleFactor, 0.95 * scaleFactor, 0.7 * scaleFactor); ear2.rotation.x = -0.2; ear2.rotation.z = 0.3; ear2.castShadow = true; horseGroup.add(ear2);
            
            const maneGeo = new THREE.ConeGeometry(0.1 * scaleFactor, 0.25 * scaleFactor, 6);
            const maneMat = new THREE.MeshStandardMaterial({ color: 0x6a3a1a });
            for (let i = 0; i < 4; i++) {
                const mane = new THREE.Mesh(maneGeo, maneMat);
                mane.position.set(0.3 + i * 0.1 * scaleFactor, 0.8 * scaleFactor, 0.6 * scaleFactor);
                mane.rotation.x = 0.3; mane.rotation.z = -0.1;
                mane.scale.set(0.8, 1, 0.8);
                mane.castShadow = true;
                horseGroup.add(mane);
            }
            horseGroup.position.set(x, 0.1, z);
            horseGroup.rotation.y = Math.PI / 2.2;
            horseGroup.scale.set(1.2, 1.2, 1.2);
            return horseGroup;
        }

        // å·¦é¦¬ã€å³é¦¬ã€å°é¦¬
        const horse1 = createHorse(-2.8, -0.2, 0.8, 0xc88a4a);
        scene.add(horse1);
        const horse2 = createHorse(3.0, -0.1, 0.85, 0x9a6a3a);
        scene.add(horse2);
        const horse3 = createHorse(-1.5, -2.2, 0.65, 0x7a5a3a);
        horse3.rotation.y = 1.0;
        scene.add(horse3);

        // ========== æ˜¥è¯ç«‹é«”è£é£¾ ==========
        function createCouplet(x, y, z) {
            const group = new THREE.Group();
            const panelMat = new THREE.MeshStandardMaterial({ color: 0xc43a1e, roughness: 0.6, emissive: 0x2a1a1a, emissiveIntensity: 0.1 });
            const panel = new THREE.Mesh(new THREE.BoxGeometry(0.28, 1.3, 0.12), panelMat);
            panel.position.y = 0.9;
            panel.castShadow = true; panel.receiveShadow = true;
            group.add(panel);
            const borderMat = new THREE.MeshStandardMaterial({ color: 0xffcc66, emissive: 0x553311, emissiveIntensity: 0.1 });
            const border = new THREE.Mesh(new THREE.BoxGeometry(0.33, 1.35, 0.03), borderMat);
            border.position.y = 0.9; border.position.z = 0.07;
            border.castShadow = true; border.receiveShadow = true;
            group.add(border);
            group.position.set(x, y, z);
            return group;
        }
        const leftCouplet = createCouplet(-1.3, 0.9, 2.25);
        scene.add(leftCouplet);
        const rightCouplet = createCouplet(1.3, 0.9, 2.25);
        scene.add(rightCouplet);
        const topBannerMat = new THREE.MeshStandardMaterial({ color: 0xc43a1e, roughness: 0.6 });
        const topBanner = new THREE.Mesh(new THREE.BoxGeometry(1.8, 0.28, 0.18), topBannerMat);
        topBanner.position.set(0, 1.9, 2.3);
        topBanner.castShadow = true; topBanner.receiveShadow = true;
        scene.add(topBanner);
        const topBorder = new THREE.Mesh(new THREE.BoxGeometry(1.85, 0.33, 0.06), new THREE.MeshStandardMaterial({ color: 0xffcc66 }));
        topBorder.position.set(0, 1.9, 2.42);
        topBorder.castShadow = true; topBorder.receiveShadow = true;
        scene.add(topBorder);

        // â˜…â˜…â˜… è²¡ç¥çˆºï¼ˆå¸¶å…ƒå¯¶ï¼‰æ¨¡å‹ Â· å°‡åŠ å…¥èµ°å…¥å‹•ç•« â˜…â˜…â˜…
        function createGodOfWealth() {
            const godGroup = new THREE.Group();
            
            // èº«é«”ï¼ˆç´…è¢ï¼‰
            const bodyGeo = new THREE.CylinderGeometry(0.45, 0.45, 1.1, 8);
            const bodyMat = new THREE.MeshStandardMaterial({ color: 0xd43a3a, roughness: 0.5, emissive: 0x3a1a1a, emissiveIntensity: 0.1 });
            const body = new THREE.Mesh(bodyGeo, bodyMat);
            body.position.y = 0.7;
            body.castShadow = true; body.receiveShadow = true;
            godGroup.add(body);
            
            // é ­
            const headGeo = new THREE.SphereGeometry(0.28);
            const headMat = new THREE.MeshStandardMaterial({ color: 0xffccaa, roughness: 0.4 });
            const head = new THREE.Mesh(headGeo, headMat);
            head.position.y = 1.32;
            head.castShadow = true; head.receiveShadow = true;
            godGroup.add(head);
            
            // å¸½å­ï¼ˆè²¡ç¥å¸½ï¼‰
            const hatGeo = new THREE.ConeGeometry(0.35, 0.5, 8);
            const hatMat = new THREE.MeshStandardMaterial({ color: 0xeebb44, emissive: 0x553311, emissiveIntensity: 0.2 });
            const hat = new THREE.Mesh(hatGeo, hatMat);
            hat.position.y = 1.62;
            hat.rotation.y = 0.3;
            hat.castShadow = true; hat.receiveShadow = true;
            godGroup.add(hat);
            
            const hatBall = new THREE.Mesh(new THREE.SphereGeometry(0.09), new THREE.MeshStandardMaterial({ color: 0xff3333, emissive: 0x441111 }));
            hatBall.position.set(0.15, 1.8, 0.1);
            hatBall.castShadow = true;
            godGroup.add(hatBall);
            
            // é¬å­
            const beardGeo = new THREE.TorusGeometry(0.18, 0.05, 6, 20, Math.PI);
            const beardMat = new THREE.MeshStandardMaterial({ color: 0xffffff, roughness: 0.9 });
            const beard = new THREE.Mesh(beardGeo, beardMat);
            beard.position.set(0, 1.12, 0.2);
            beard.rotation.x = 0.2;
            beard.rotation.z = 0.1;
            beard.scale.set(1, 0.4, 0.3);
            beard.castShadow = true;
            godGroup.add(beard);
            
            // å·¦æ‰‹å…ƒå¯¶ï¼ˆé‡‘è‰²ï¼‰
            const yuanBaoGroup = new THREE.Group();
            const yuanBaoMain = new THREE.Mesh(new THREE.SphereGeometry(0.13), new THREE.MeshStandardMaterial({ color: 0xffdd44, emissive: 0x553300, emissiveIntensity: 0.2 }));
            yuanBaoMain.scale.set(1.2, 0.5, 0.8);
            yuanBaoMain.rotation.z = 0.5;
            yuanBaoMain.castShadow = true;
            yuanBaoGroup.add(yuanBaoMain);
            
            const yuanBaoTop = new THREE.Mesh(new THREE.TorusGeometry(0.1, 0.04, 6, 16, Math.PI), new THREE.MeshStandardMaterial({ color: 0xffcc33 }));
            yuanBaoTop.rotation.x = 1.5;
            yuanBaoTop.position.y = 0.1;
            yuanBaoTop.scale.set(1, 0.4, 0.5);
            yuanBaoTop.castShadow = true;
            yuanBaoGroup.add(yuanBaoTop);
            
            yuanBaoGroup.position.set(0.5, 1.0, 0.4);
            yuanBaoGroup.rotation.z = -0.4;
            yuanBaoGroup.rotation.x = 0.3;
            godGroup.add(yuanBaoGroup);
            
            // å³æ‰‹è‡ªç„¶æ“ºå‹•
            const rightHand = new THREE.Mesh(new THREE.SphereGeometry(0.13), new THREE.MeshStandardMaterial({ color: 0xffccaa }));
            rightHand.position.set(-0.45, 0.95, 0.35);
            rightHand.castShadow = true;
            godGroup.add(rightHand);
            
            godGroup.position.y = 0.2;
            return godGroup;
        }

        // å»ºç«‹è²¡ç¥ï¼Œæ”¾åœ¨èµ·å§‹é»ï¼ˆå·¦å´é è™•ï¼‰
        const godOfWealth = createGodOfWealth();
        godOfWealth.position.set(-6.5, 0.25, -1.0);
        godOfWealth.rotation.y = 0.6;
        scene.add(godOfWealth);

        // â˜…â˜…â˜… å…ƒå¯¶å™´æ³‰ç³»çµ±ï¼šè¨±å¤šå…ƒå¯¶å¾å¥‰å¤©å®®å»Ÿé–€/å±‹é ‚å™´å‡º â˜…â˜…â˜…
        const ybArray = [];
        function createYuanBao() {
            const group = new THREE.Group();
            const main = new THREE.Mesh(new THREE.SphereGeometry(0.12), new THREE.MeshStandardMaterial({ color: 0xffdd44, emissive: 0x553300, emissiveIntensity: 0.2 }));
            main.scale.set(1.2, 0.5, 0.8);
            main.castShadow = true; main.receiveShadow = true;
            group.add(main);
            const topRing = new THREE.Mesh(new THREE.TorusGeometry(0.09, 0.03, 6, 16, Math.PI), new THREE.MeshStandardMaterial({ color: 0xffcc33 }));
            topRing.rotation.x = 1.5;
            topRing.position.y = 0.08;
            topRing.scale.set(1, 0.4, 0.5);
            topRing.castShadow = true;
            group.add(topRing);
            return group;
        }

        // åˆå§‹åŒ– 60 å€‹å…ƒå¯¶ï¼Œæ”¾åœ¨å»Ÿçš„å‘¨åœç™¼å°„é» (å¾å»Ÿä¸­å¿ƒå™´å‡º)
        for (let i = 0; i < 80; i++) {
            const yb = createYuanBao();
            // éš¨æ©Ÿèµ·å§‹ä½ç½®ï¼šå»Ÿé–€é™„è¿‘ (x: -1.5~1.5, y: 1.5~3.5, z: 1.8~2.2) ä»¥åŠå±‹é ‚å€åŸŸ
            const spawnX = (Math.random() - 0.5) * 3.2;
            const spawnY = 1.8 + Math.random() * 2.2;
            const spawnZ = 1.6 + Math.random() * 1.2;
            yb.position.set(spawnX, spawnY, spawnZ);
            
            // éš¨æ©Ÿé€Ÿåº¦å‘é‡
            const vx = (Math.random() - 0.5) * 0.08;
            const vy = 0.03 + Math.random() * 0.08;
            const vz = (Math.random() - 0.5) * 0.08;
            
            scene.add(yb);
            ybArray.push({
                mesh: yb,
                vel: new THREE.Vector3(vx, vy, vz),
                life: Math.random() * 100 + 50,
                maxLife: 120
            });
        }

        // å†åŠ ä¸€äº›å…ƒå¯¶å¾å»Ÿé ‚å¯¶é ‚å™´å‡º
        for (let i = 0; i < 30; i++) {
            const yb = createYuanBao();
            yb.position.set((Math.random()-0.5)*2.5, 4.0 + Math.random()*1.2, (Math.random()-0.5)*1.5);
            const vx = (Math.random() - 0.5) * 0.09;
            const vy = 0.04 + Math.random() * 0.09;
            const vz = (Math.random() - 0.5) * 0.09;
            scene.add(yb);
            ybArray.push({
                mesh: yb,
                vel: new THREE.Vector3(vx, vy, vz),
                life: Math.random() * 80 + 40,
                maxLife: 120
            });
        }

        // æ¼‚æµ®å…ƒå¯¶ (è·Ÿéš¨è²¡ç¥)
        const floatingYuan = new THREE.Mesh(new THREE.SphereGeometry(0.1), new THREE.MeshStandardMaterial({ color: 0xffaa00, emissive: 0x553300 }));
        floatingYuan.scale.set(1.2, 0.5, 0.8);
        floatingYuan.position.set(-6.5, 1.1, -0.8);
        scene.add(floatingYuan);
        
        // æ§åˆ¶è¦–è§’
        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.06;
        controls.autoRotate = true;
        controls.autoRotateSpeed = 0.5;
        controls.enableZoom = true;
        controls.enablePan = true;
        controls.target.set(0, 1.8, 0);

        // å‹•ç•«ï¼šè²¡ç¥èµ°å…¥ã€å…ƒå¯¶å™´æ³‰æ›´æ–°
        let godDirection = 1;
        let godStep = 0;

        function animate() {
            requestAnimationFrame(animate);
            
            // è²¡ç¥èµ°å…¥å‹•ç•«ï¼šä¾†å›èµ°å‹•
            godStep += 0.012;
            if (godDirection > 0) {
                godOfWealth.position.x += 0.025;
                floatingYuan.position.x += 0.025;
                if (godOfWealth.position.x >= 2.2) { godDirection = -1; }
            } else {
                godOfWealth.position.x -= 0.025;
                floatingYuan.position.x -= 0.025;
                if (godOfWealth.position.x <= -6.0) { godDirection = 1; }
            }
            godOfWealth.position.y = 0.25 + Math.sin(Date.now() * 0.006) * 0.04;
            floatingYuan.position.y = 1.1 + Math.sin(Date.now() * 0.008) * 0.1;
            floatingYuan.rotation.y += 0.03;
            
            // â˜…â˜…â˜… å…ƒå¯¶å™´æ³‰ï¼šç§»å‹•ã€æ—‹è½‰ã€é‡ç½® â˜…â˜…â˜…
            ybArray.forEach(item => {
                // ç§»å‹•
                item.mesh.position.x += item.vel.x;
                item.mesh.position.y += item.vel.y;
                item.mesh.position.z += item.vel.z;
                
                // æ—‹è½‰
                item.mesh.rotation.x += 0.05;
                item.mesh.rotation.y += 0.08;
                item.mesh.rotation.z += 0.04;
                
                // é‡åŠ›å½±éŸ¿ï¼Œç¨å¾®ä¸‹é™
                item.vel.y -= 0.0025;
                
                // é‚Šç•Œé‡ç½®ï¼šæ‰åˆ°åœ°é¢ä»¥ä¸‹æˆ–å¤ªé ï¼Œå°±é‡ç½®å›å»Ÿå£
                if (item.mesh.position.y < 0.2 || Math.abs(item.mesh.position.x) > 8 || Math.abs(item.mesh.position.z) > 6) {
                    // é‡æ–°å‡ºç”Ÿåœ¨å»Ÿé–€é™„è¿‘
                    item.mesh.position.x = (Math.random() - 0.5) * 3.0;
                    item.mesh.position.y = 2.0 + Math.random() * 2.0;
                    item.mesh.position.z = 1.8 + Math.random() * 1.0;
                    // æ–°é€Ÿåº¦
                    item.vel.x = (Math.random() - 0.5) * 0.08;
                    item.vel.y = 0.05 + Math.random() * 0.09;
                    item.vel.z = (Math.random() - 0.5) * 0.08;
                }
            });
            
            controls.update();
            renderer.render(scene, camera);
        }
        animate();

        window.addEventListener('resize', () => {
            const w = canvas.clientWidth;
            const h = canvas.clientHeight;
            renderer.setSize(w, h);
            camera.aspect = w / h;
            camera.updateProjectionMatrix();
        });

        // ---------- äº’å‹•æ ¸å¿ƒ Â· 3Dæ–‡å­—æ”¾å¤§ï¼‹JACKYéŸ³æ•ˆï¼‹æ“²ç­Š ----------
        const moon = document.getElementById('moonDisplay');
        const resultMsg = document.getElementById('resultMessage');
        const shakeArea = document.getElementById('shakeArea');
        const blessDisplay = document.getElementById('blessDisplay');
        
        const audio = document.getElementById('bgMusic');
        const musicBtn = document.getElementById('musicToggle');
        let isPlaying = true;

        const blessings = [
            "ğŸ’° å…ƒå¯¶å¾å¥‰å¤©å®®å™´å‡ºä¾†å•¦ï¼è²¡ç¥åˆ°",
            "ğŸ´ Jacky é›™é¦¬å¥”é¨° Â· å…ƒå¯¶æ»¿å¤©é£›",
            "ğŸ® è–ç­Šé€£é€£ Â· å¥‰å¤©å®®é‡‘å¹£ç‘ä¸åœ",
            "ğŸ§§ åƒé¡†å…ƒå¯¶è¬å…©é‡‘ Â· è²¡ç¥çˆºè³œç¦",
            "ğŸƒ è²¡ç¥é™ªä½ è·‘ Â· å…ƒå¯¶ä¸€è·¯ç™¼",
            "ğŸŒ² å…ƒå¯¶æ‰é€²æ£®æ— Â· è‡ªç„¶ç”Ÿè²¡",
            "â˜ï¸ å¤©é™å…ƒå¯¶ Â· ç¦æ°£æ»¿å¤©",
            "â›°ï¸ å…ƒå¯¶å †æˆå±± Â· æ­¥æ­¥é«˜å‡",
            "ğŸ‹ è²¡ç¥è³œè–ç­Š Â· è¬äº‹å¦‚æ„"
        ];

        function initAudio() {
            audio.volume = 0.4;
            const playPromise = audio.play();
            if (playPromise !== undefined) {
                playPromise.then(() => { isPlaying = true; musicBtn.textContent = 'ğŸ”Š'; })
                .catch(() => { isPlaying = false; musicBtn.textContent = 'ğŸ”‡'; });
            }
        }
        initAudio();

        musicBtn.addEventListener('click', () => {
            if (isPlaying) { audio.pause(); musicBtn.textContent = 'ğŸ”‡'; isPlaying = false; }
            else { audio.play().then(() => { musicBtn.textContent = 'ğŸ”Š'; isPlaying = true; }); }
        });

        function playJACKY() {
            try {
                const AudioContext = window.AudioContext || window.webkitAudioContext;
                const ctx = new AudioContext();
                if (ctx.state === 'suspended') ctx.resume();
                function playJa(time, pan, vol) {
                    const osc = ctx.createOscillator();
                    const gain = ctx.createGain();
                    const panner = ctx.createStereoPanner();
                    osc.type = 'sawtooth'; osc.frequency.value = 780;
                    panner.pan.value = pan; gain.gain.value = vol;
                    osc.connect(gain); gain.connect(panner); panner.connect(ctx.destination);
                    osc.start(time); osc.stop(time + 0.13);
                    gain.gain.exponentialRampToValueAtTime(0.001, time + 0.11);
                }
                function playCky(time, pan, vol) {
                    const osc = ctx.createOscillator(); const gain = ctx.createGain(); const panner = ctx.createStereoPanner();
                    osc.type = 'triangle'; osc.frequency.value = 520;
                    panner.pan.value = pan; gain.gain.value = vol;
                    osc.connect(gain); gain.connect(panner); panner.connect(ctx.destination);
                    osc.start(time); osc.stop(time + 0.15);
                    gain.gain.exponentialRampToValueAtTime(0.001, time + 0.13);
                }
                function playKey(time, pan, vol) {
                    const osc = ctx.createOscillator(); const gain = ctx.createGain(); const panner = ctx.createStereoPanner();
                    osc.type = 'sawtooth'; osc.frequency.value = 920;
                    panner.pan.value = pan; gain.gain.value = vol;
                    osc.connect(gain); gain.connect(panner); panner.connect(ctx.destination);
                    osc.start(time); osc.stop(time + 0.13);
                    gain.gain.exponentialRampToValueAtTime(0.001, time + 0.11);
                }
                const now = ctx.currentTime;
                playJa(now, -0.5, 0.4); playCky(now+0.09, -0.4, 0.38); playKey(now+0.18, -0.3, 0.42);
                playJa(now+0.4, 0.3, 0.45); playCky(now+0.49, 0.4, 0.43); playKey(now+0.58, 0.5, 0.46);
                playJa(now+0.85, -0.2, 0.5); playCky(now+0.94, 0.1, 0.48); playKey(now+1.03, 0.0, 0.52);
            } catch(e) {}
        }

        function doSheng() {
            moon.textContent = 'ğŸ¥¢ğŸ¥¢';
            resultMsg.innerHTML = 'ğŸ¥¢ğŸ¥¢ Jacky è²¡ç¥è–ç­Š Â· å…ƒå¯¶çˆ†ç™¼ ğŸª™';
            const text = blessings[Math.floor(Math.random() * blessings.length)];
            blessDisplay.textContent = text;
            blessDisplay.classList.remove('sheng-text-3d');
            void blessDisplay.offsetWidth;
            blessDisplay.classList.add('sheng-text-3d');
            playJACKY();
            if (navigator.vibrate) navigator.vibrate([30, 40, 30, 60]);
            setTimeout(() => blessDisplay.classList.remove('sheng-text-3d'), 1000);
        }

        let lastShake = 0;
        if (window.DeviceMotionEvent) {
            window.addEventListener('devicemotion', (e) => {
                const acc = e.accelerationIncludingGravity;
                if (!acc) return;
                const now = Date.now();
                if (now - lastShake < 1000) return;
                const x = Math.abs(acc.x || 0); const y = Math.abs(acc.y || 0); const z = Math.abs(acc.z || 0);
                if ((x > 9.8 || y > 9.8 || z > 9.8) && (x + y + z > 25)) { lastShake = now; doSheng(); }
            });
        }

        moon.addEventListener('click', doSheng);
        shakeArea.addEventListener('click', doSheng);

        blessDisplay.textContent = "ğŸ’° å…ƒå¯¶æ»¿åœ°å † Â·  æ–è–ç­Šè¿é›™é¦¬";
    </script>
</body>
</html>